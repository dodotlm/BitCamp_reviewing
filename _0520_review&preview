## 멀티 스레드

- 멀티 프로세스라는 틀 안에 멀티 스레드가 있다. 프로세스 안에서 여러 스레드가 동시에 작동되어지는 건데...
- 이 멀티 스레드라는 것은 우리가 이클립스 터미널 결과창에서 볼 수 있는 결과들이 순서없이 나올 수 있다.
- 무슨 말이냐면 멀티 스레드1, 멀티 스레드2가 있으면 특별하게 조작하지 않은 이상 멀티 스레드1과 멀티 스레드2의 결과가 둘 구분없이, 순서없이 찍히게 된다는 것이다.

- 또 다른 특징이라고 한다면 프로세스들은 독립적이라 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 상관이 없다.
- 하지만 스레드는 문제가 생기면 그 프로그램이 종료되게 된다.

- 스레드 생성
-> 스레드의 생성에는 두 가지가 있다.
1. 스레드 Runnable 객체 생성

Thread thread = new Thread(Runnable task);

MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);

이처럼  Thread 스레드객체이름 = new Thread(Runnable객체); 느낌으로 생성을 하곤한다.

2. 스레드 클래스 확장

public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread is running");
    }
이렇게 Thread확장을 해주고 오버라이드 시켜준다.
물론 메인 메소드에서 해당 스레드 클래스의 객체를 만들고 사용해야한다. (이건 다른 일반 클래스도 객체 생성 후 이용해야 하는거 잊어버리지 않았재?)


- 스레드 기능메소드

start() : 해당 스레드를 실행 대기 큐에 넣는다. 실행되는 건 아님!
sleep() : sleep안에 몇 초 동안 일시정지 할지 초를 넣을 수 있다. ex) sleep(5000) : 0.5초 일시정지
join() : 먼저 실행 대기 큐에 있거나 먼저 작동하고 있는 스레드를 멈추게 하고 해당 스레드를 먼저 실행시키게 함.
-> 멈춰진 스레드들은 해당 스레드가 끝나야 다시 실행 가능함.
=> 이들은 (특히 sleep) try-catch문을 이용하는 것이 좋다. 아니 이용해라.

t1.start();
t2.start();
t2.join();

만약 이런 식으로 있었다고 해보자 t1은 실행대기큐에 들어가 있다.
그리고 그 다음에 t2도 실행대기큐에 들어가 있다.
근데 별다른 메소드들이 중간에 껴 있는게 아니라 그 다음 join이 바로 와버리므로 t1을 비롯한 다른 스레드는 젠부 멈추게 된다.













