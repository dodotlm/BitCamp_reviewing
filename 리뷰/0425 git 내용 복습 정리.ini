# git 내용 복습 정리

## 1.0424 간단 정리
1. working space - staging space - local repos - remote repos
2. add -> commit -> push 순으로 이루어진다
3-1. 그 역은 clone으로 모조리 다운받거나
3-2. pull로 최신 버전과 내 로컬 저장소를 병합한다거나
3-3. fetch로 비교해보거나 그러다가 병합의 필요성이 느껴지면 merge를 사용한다.

## 2. git에 올릴 때는
1. 우선 로컬 저장소를 생성해 내야 한다. [ git init ]
2. git과 github의 브랜치가 다르기 때문에 "master"에서 "main"으로 바꿔준다 [ git branch -M main ]
3. 이제 작업 영역에서 staging 영역으로 옮겨야 한다. add 명령어를 사용해 주자. [ git add 파일이름.확장자 ]
4. staging 영역에서 local 저장소로 옮길 차례이다. commit 명령어를 사용해주자. [ git commit -m "내가 뭘 어떻게 바꿨게~" ]
4-1. [ git log ]를 사용하면 지금 커밋된 것들의 기록을 쭈욱 볼 수 있다.
5. 이제 로컬 저장소에서 원격 저장소로 옮겨야 하는데 그 전에 이 둘을 연결해 줘야 한다. [ git remote add origin 복사한 원격 저장소 주소 ]
5-1. 복사한 원격 저장소 위치는 github에 repository에서 찾을 수 있다. 못 찾았다면 그냥 그 저장소 주소를 복사하고 거기에 .git을 붙이면 된다.
5-2. 만약 이미 연결되어 있다고 오류가 나면 [ git remote remove origin ] //origin이 뭘까 //초기 상태의 원격 저장소 이름 //그게 아니라 원격 저장소 그 자체를 지칭하는 것이라고 생각하면 된다.
5-3. 이제 푸시를 해주자 [ git push origin main ] // origin은 원격 저장소의 초기 브랜치이고 main은 로컬 저장소의 브랜치이므로 [ git push 원격저장소 로컬저장소브랜치 ] 이렇게 생각해도 될까?




## 3. git에서 내려받을 때는
1. 우선 그냥 그대로 다 내려받기 위해서는 clone을 사용해주는 것이 맞다.
1-1. 내려받을 곳의 github repos 주소를 따온다.
1-2. clone명령어를 써준다. [ git clone 내려받는 곳의 주소 ] 혹은 [ git clone 내려받는 곳의 주소 . ]
ㄴ 이 둘의 차이는 전자의 경우는 폴더채로 가져오는 것이고 후자는 폴더 내의 내용물만 가져오는 것이라고 보면 된다.
2. pull 같은 경우에는 다운 받는 것이 아니라 내 로컬에 이전 버전의 파일이 있고 원격 저장소에 최신 버전 파일이 있다면 그것만 새걸로 갱신해주는 것이라고 생각하면 된다.
2-1. [ git pull origin main ]
// 궁금증, git에 올릴 때는 로컬과 원격을 연결했었는데 내려받을 때는 왜 이 과정이 필요없는건가? 
// 정답은 이미 로컬 저장소가 원격 저장소와 연결되어 있으므로 할 필요가 없는 것이다. 
// 디렉토리에 .git파일이 로컬 저장소인데 그 디렉토리에서 원격저장소에 파일을 올리기 위해 연결을 했었다면 그 연결이 remove하지 않는 이상 계속 이어지게 되는 것이므로 
//정확히는 다운받을 때는 필요없는게 아니라 원격 저장소와 연결되어 있는 로컬 저장소가 건재하기 때문에 연결 안하는 것이다. 오케이


## 4. 소스트리의 이용
1. working space에서 staging area로 이동
2. 커밋
3. 푸시

이렇게만 기억하면 된다. 했던 내용이니 그대로 행하면 될 듯. 명령어 없이 하니까 편하긴 하네ㅇㅇ
처음에 소스코드 도구>옵션>인증 들어가서 내 github 계정 연결하는 거 까먹지 않고 사용하면 될 것 같다.


## 5. 소스트리에서의 브랜치
1. 위에서는 커밋을 명령어로써 생각하며 진행해 왔지만 사실 커밋은 "버전"이라는 의미로 생각을 해야한다.
2. 소스코드에서는 처음 커밋을 실시하면 main 브랜치로 들어가게 된다. 이 main 브랜치는 계속 기준이 되는 브랜치가 될 것이다.
3. 따라서 어떠한 브랜치가 어떤 커밋(버전) 기준으로 생성될 수 있다. 새로운 브랜치는 main브랜치에서 나오는 것이 바람직하다.
4. 소스트리를 보면 커밋 옆에 그래프 같은게 있는데 이게 모든 브랜치가 main브랜치와 한 길을 간다면(다른 내용이 없다면) 직선으로 나오겠지만 다른 내용이 생겨버리면 그때는 갈라지는 그래프가 그려지게 된다.
// checkout이라는 명령어가 있는데 이는 다른 브랜치로 옮겨 갈 때 사용하는 명령어 이다. 소스트리에서는 그냥 다른 브랜치를 더블클릭 하면 될 뿐이다.

ㄴ 따라서 이 브랜치들이 난립하게 되는데 코드 상 이것들을 하나로 합칠 필요가 있다. 이를 병합(merge)한다고 한다.
5. main 브랜치 기준으로 시작. 소스트리 창을 보았을 때 main과 병합이 필요한 브랜치의 커밋을 우클릭하여 병합을 한다.
6. 그러면 반영되지 않은 커밋들이 생겨나므로 푸쉬를 해줄 필요가 생긴다. 고맙게도 소스트리는 다 뭐하라고 표시를 해준다.
7. 위 같은 경우에서 충돌오류가 안난다면 이는 동일한 파일에서 각각의 수정을 하지 않아서이다. 동일한 파일 내에서 각각 내용이 다른 경우 충돌이 날 수 밖에 없다.

8. 자, main 브랜치와 다른 길을 간, 충돌이 날 것이 자명한 브랜치를 병합해 보도록 하자.
8-1. 이런 충돌 가능성이 있는 브랜치는 일단 main 브랜치에서 병합을 하는 것이 아닌 충돌 브랜치에서 병합을 진행해야 한다.
8-2. 충돌 브랜치로 체크아웃(이동)해서 main 브랜치의 최신 커밋을 우클릭하여 병합해준다.
8-3. 그러면 충돌이 났다고 오류창이 뜨면서 해당 파일에 어느 부분이 달라서 충돌이 났는지 다 나오게 된다.
8-4. 이걸 이제 스테이지에 add하고 커밋, 그리고 푸시까지 해주면 된다.
8-5. 이제 안전하게 병합 커밋이 충돌 브랜치에 올라간 상황이니까 이걸 main 브랜치에 반영을 해주면 된다.
8-6. main 브랜치로 checkout해서 최신 커밋을 우클릭 후 병합을 선택해 주면 된다. 그 후 원격 저장소 main에도 반영해주어야 하므로 알림이 떠 있는 push를 진행해주면 된다.
8-7. 이렇게 하면 다른 내용이 있었던 브랜치의 내용을 main 브랜치로 무사히 반영을 할 수 있게 된다.

9. 위에서 merge에 대해서 했으니 이제는 pull에 대해서 공부해볼 차례이다. pull은 merge보다 예의바르게 병합을 하는 느낌이라고 생각하면 된다.
9-1. [pull request]는 서로가 승인을 해야지만 병합이 가능한 시스템이다.
9-2. 8번 부분에서 처럼 main과 다른 길을 간 브랜치를 충돌 브랜치로 그냥 명명하고 진행해보자.
9-3. 만약 충돌 브랜치로 파일을 원격 저장소에까지 올렸으면 github 들어가 repository 들어가서 확인해 보면 방금 푸쉬한 브랜치를 알려주며 pull request 할 수 있는 버튼이 활성화 된다.
9-4. 들어가보면 base branch와 compare branch를 설정해야 한다. 보통 base에 main을 올리고 compare에는 충돌 브랜치를 올린다.
9-5. 제목과 내용을 적어주고 옆에 reviewers를 몇 명을(승인을 몇명한테 받을 건지) 할 것인지, 그 밑에 assigners는 자기를 적고, label에는 뭘 했는지 한~두개의 단어로 지정해주면 된다.
9-6. 그러고 pull request해주면 원격 저장소의 협업자가 이를 확인하고 검토가 가능하다. 협업자는 수락,수정요청,병합을 진행 할 수 있다. 최종 통수권자가 병합을 주로 진행한다.
9-7. Merge pull request 버튼을 클릭하고 그 다음 창에서는 Confirm merge 버튼을 클릭. 그러면 병합 완료이다.
9-8. 소스트리 로컬 저장소에는 아직 반영이 안되었기 때문에 소스트리 pull request브랜치에서 fetch(패치) 버튼을 눌러준다.
9-9. main 브랜치는 패치가 아니라 아예 코드까지 다 가져와야 하므로 pull을 사용한다. Pull 버튼을 눌러서 원격 저장소에 병합된 내용을 로컬 저장소로 가져온다.

10. 쉽지 않다. 그냥 따라하면 하겠는데 이해하면서 해야 하니까 힘들다. 써보면서 늘겠지.











