## 멀티 스레드

- 멀티 프로세스라는 틀 안에 멀티 스레드가 있다. 프로세스 안에서 여러 스레드가 동시에 작동되어지는 건데...
- 이 멀티 스레드라는 것은 우리가 이클립스 터미널 결과창에서 볼 수 있는 결과들이 순서없이 나올 수 있다.
- 무슨 말이냐면 멀티 스레드1, 멀티 스레드2가 있으면 특별하게 조작하지 않은 이상 멀티 스레드1과 멀티 스레드2의 결과가 둘 구분없이, 순서없이 찍히게 된다는 것이다.

- 또 다른 특징이라고 한다면 프로세스들은 독립적이라 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 상관이 없다.
- 하지만 스레드는 문제가 생기면 그 프로그램이 종료되게 된다.

- 스레드 생성
-> 스레드의 생성에는 두 가지가 있다.
1. 스레드 Runnable 객체 생성

Thread thread = new Thread(Runnable task);

MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);

이처럼  Thread 스레드객체이름 = new Thread(Runnable객체); 느낌으로 생성을 하곤한다.

2. 스레드 클래스 확장

public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread is running");
    }
이렇게 Thread확장을 해주고 오버라이드 시켜준다.
물론 메인 메소드에서 해당 스레드 클래스의 객체를 만들고 사용해야한다. (이건 다른 일반 클래스도 객체 생성 후 이용해야 하는거 잊어버리지 않았재?)


- 스레드 기능메소드

start() : 해당 스레드를 실행 대기 큐에 넣는다. 실행되는 건 아님!
sleep() : sleep안에 몇 초 동안 일시정지 할지 초를 넣을 수 있다. ex) sleep(5000) : 0.5초 일시정지
join() : 먼저 실행 대기 큐에 있거나 먼저 작동하고 있는 스레드를 멈추게 하고 해당 스레드를 먼저 실행시키게 함.
-> 멈춰진 스레드들은 해당 스레드가 끝나야 다시 실행 가능함.
=> 이들은 (특히 sleep) try-catch문을 이용하는 것이 좋다. 아니 이용해라.

t1.start();
t2.start();
t2.join();

만약 이런 식으로 있었다고 해보자 t1은 실행대기큐에 들어가 있다.
그리고 그 다음에 t2도 실행대기큐에 들어가 있다.
근데 별다른 메소드들이 중간에 껴 있는게 아니라 그 다음 join이 바로 와버리므로 t1을 비롯한 다른 스레드는 젠부 멈추게 된다.

자 이렇게 멈추게 된 스레드를 다시 실행대기 상태로 되돌리려면 notify() 메소드를 사용하면 된다.

이 와중에 스레드들 간의 예의를 지키는 메소드가 있다.
바로 yield() 메소드는 현재 스레드를 실행 대기 상태로 변경시키고 다른 스레드에게 실행 순서를 양보한다.


- 스레드의 동기화

말이 어렵지 스레드의 동기화는 서로 섞일 수도 있는 스레드 때문에 변수의 값이 달라지게 되는 것을 방지하기 위함이다.

 메소드() {
        synchronized(공유객체의 변수명) {
            //단 하나의 스레드에서만 실행되는 코드
        }
    }

이렇게 synchronized로 잠궈놓는다. 이렇게 잠궈놓으면 다른 스레드가 만약 작동하면서 건드리려고 해도 끄떡없다.


- run() 메소드의 코드가 다 끝나면 종료되지만 다 끝나기 전에 종료해야 하는 경우 스레드의 안전한 종료는 interrupt() 메소드를 사용한다.

- 데몬 스레드 : 보조 스레드
.setDaemon(true) 메소드를 데몬 스레드로 만들어준다.

- 스레드 풀... 추가 바람









